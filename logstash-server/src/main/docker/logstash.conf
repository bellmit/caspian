#
# Copyright (c) 2015 EMC Corporation
# All Rights Reserved
#
# This software contains the intellectual property of EMC Corporation
# or is licensed to EMC Corporation from third parties.  Use of this
# software and the intellectual property contained therein is expressly
# limited to the terms and conditions of the License Agreement under which
# it is provided by or on behalf of EMC.
#


input {
    courier {
        transport => "tcp"
        port => 5040
    }
}

filter {
    grok {
        patterns_dir => "./patterns"
    }

    grok {
        match => [ "path", "/opt/emc/caspian/%{GREEDYDATA:restOfThePath}"]
    }
    mutate {
        replace => { "path" => "/opt/emc/caspian/logs/%{restOfThePath}" }
        remove_field => [ "restOfThePath" ]
    }

    if [parttype] == "keystone" or [parttype] == "cc_keystone"{
        multiline {
            pattern => "^(?>\d\d){1,2}|^\["
            negate => "true"
            what => "previous"
        }

        grok {
            match => [
                # For main.log and admin.log
                "message", "%{KEYSTONE_MAIN_ADMIN1}",
                "message", "%{KEYSTONE_MAIN_ADMIN2}",
                # For ssl_access.log
                "message", "%{COMBINEDAPACHELOG_CUSTOM}",
                # For keystone-apache-error.log
                "message", "%{KEYSTONE_APACHEERROR}",
                # For idpmonitor.log
                "message", "%{KEYSTONE_IDPMONITOR}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}"
            ]
        }

        mutate {
            add_field => { "timestamp" => "%{monthDay}%{month}%{year} %{time}"}
        }

        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss.SSS", "dd/MMM/yyyy:HH:mm:ss Z", "ddMMMYYYY HH:mm:ss.SSSSSS", "ISO8601", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSSSSS"]
            target => "@timestamp"
            locale => "en"
            timezone => "UTC"
        }
    }

    #Caspian Compute
    else if [parttype] == "cc_rabbitmq" {
        multiline {
            pattern => "^=|^\b(?:[0-9]+)\b"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For rabbit@<hostname>.log
                "message", "%{RABBITMQ_HOSTNAMELOG}",
                # For supervisord.log
                "message", "%{RABBITMQ_SUPERVISOR}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
           ]
        }

        mutate {
            add_field => { "timestamp" => "%{monthDay}%{month}%{year} %{time}"}
        }
        date {
            match => [ "timestamp", "ddMMMYYYY HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "cc_c3" {
        multiline {
            pattern => "^\b(?:[0-9]+)\b|^\["
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For access.log
                "message", "(?m)%{COMBINEDAPACHELOG_CUSTOM}",
                # For error.log
                "message", "%{C3_ERROR}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}"
            ]
        }

        date {
            match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "etcd-service" or [parttype] == "mysql" or [parttype] == "mysql-galera" or [parttype] == "db-controller" or [parttype] == "elasticsearch" or [parttype] == "cc_mysql"{
        multiline {
            pattern => "^\b(?:[0-9]+)\b|^\["
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For db_controller
                "message", "%{LICENSE__DBCONTROLLER}",
                # For elasticsearch
                "message", "%{ELASTICSEARCH}",
                "message", "%{ELASTICSEARCH_FETCH_QUERY}",
                "message", "%{ELASTICSEARCH_INDEX}",
                "message", "%{ELASTICSEARCH_ZYPPER}",
                # MYSQLx are various patterns observed for mysql logs. Newer ones to be added above these so as to be executed first
                "message", "%{MYSQL1}",
                "message", "%{MYSQL2}",
                "message", "%{MYSQL3}",
                "message", "%{MYSQL4}",
                "message", "%{MYSQL5}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
        mutate {
            add_field => { "timestamp" => "%{date} %{time}" }
        }
        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss", "YYMMdd H:mm:ss", "YYMMdd HH:mm:ss", "YYYYMMdd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }

        mutate {
            convert => {
                # type numeric fields (they're strings by default)
                "took_millis" => "integer"
                "total_shards" => "integer"
                "shard" => "integer"
            }
        }
    }

    else if [parttype] == "cc_nova_compute" {
        multiline {
            pattern => "^(?>\d\d){2}"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For nova-api.log
                "message", "%{NOVA_API}",
                # For nova-cert.log
                "message", "%{NOVA_CERT}",
                # For nova-conductor.log, nova-consoleauth.log, nova-novncproxy.log, nova-scheduler.log
                "message", "%{NOVA_CONDUCTOR_CONSOLEAUTH_NOVNCPROXY_SCHEDULER}",
                # For nova-conductor.log, nova-consoleauth.log, nova-manage.log, nova-novncproxy.log, nova-scheduler.log
                "message", "%{NOVA_COMPUTE6}",
                "message", "%{NOVA_CONDUCTOR_CONSOLEAUTH_MANAGE_NOVNCPROXY_SCHEDULER_COMPUTE1}",
                # For nova-compute.log
                "message", "%{NOVA_COMPUTE2}",
                "message", "%{NOVA_COMPUTE3}",
                # For ovs-vswitchd.log, ovsdb-server.log
                "message", "%{NOVA_COMPUTE4}",
                # For qemu logs
                "message", "%{NOVA_COMPUTE5}",
                # For supervisord.log
                "message", "%{NOVA_SUPERVISORD}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }

        date {
            match => [ "timestamp", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "cc_cinder_controller" {
        multiline {
            pattern => "^(?>\d\d){2}"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For cinder-{api, manage, scheduler, volume}.log
                "message", "%{CINDER_API_MANAGE_SCHEDULER_VOLUME}",
                # For supervisord.log
                "message", "%{CINDER_SUPERVISORD}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }

        date {
            match => [ "timestamp", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "cc_glance_controller" {
        multiline {
            pattern => "^(?>\d\d){2}"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For api.log, registry.log
                "message", "%{GLANCE_API_REGISTRY}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }

        date {
            match => [ "timestamp", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "cc_heat_controller" {
        multiline {
            pattern => "^\b(?:[0-9]+)\b"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For heat-{api-cfn, api-cloudwatch, manage, engine}.log
                "message", "%{HEAT_CFN_CLOUDWATCH_MANAGE_ENGINE}",
                # For supervisord.log
                "message", "%{HEAT_SUPERVISORD}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
        if [className] == "heat.engine.stack" and [severity] == "INFO" {
            grok {
                match => [ "message", "%{TIMESTAMP_ISO8601}\s*%{NONNEGINT}\s*%{WORD}\s*%{USERNAME:}\s*.*Stack CREATE %{WORD:heatEngineStatus}"]
            }
        }

        date {
            match => [ "timestamp", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "cc_neutron_controller" {
        multiline {
            pattern => "^(?>\d\d){2}"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
		# For WSGI logs
                "message", "%{NEUTRON_WSGI_HTTP_API_2}",
                "message", "%{NEUTRON_WSGI_HTTP_API_1}",
                # For neutron-{{dhcp, l3, lbaas, metadata, openvswitch}-agent, server}.log
                "message", "%{NEUTRON_SERVER_DHCPAGENT_L3AGENT_LBAASAGENT_METADATAAGENT_OPENVSWITCHAGENT}",
                # For ovs-vswitchd.log
                "message", "%{NEUTRON_VSWITCHD}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
	mutate {
            gsub => [ "deviceid", "&device_id=", ","]
            split => { "deviceid" => ","}
        }
        date {
            match => [ "timestamp", "YYYY-MM-dd HH:mm:ss.SSS", "ISO8601", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "cc_ceilometer" {
        multiline {
            pattern => "^(?>\d\d){2}"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For For ceilometer-{agent-notification, alarm-notifier, api, collector, dbsync}.log
                "message", "%{CEILOMETER_NOTIFICATION_NOTIFIER_API_COLLECTOR_DBSYNC}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }

        date {
            match => [ "timestamp", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "cc_horizon" {
        multiline {
            pattern => "^\b(?:[0-9]+)\b|^\["
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For access_log, openstack-dashboard-access_log
                "message", "%{COMBINEDAPACHELOG_CUSTOM}",
                # For error_log, openstack-dashboard-error_log
                "message", "%{HORIZON_ERROR}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}"
            ]
        }
        mutate {
            add_field => { "timestamp" => "%{monthDay}%{month}%{year} %{time}"}
        }
        date {
            match => [ "timestamp", "ddMMMYYYY HH:mm:ss.SSSSSS", "dd/MMM/yyyy:HH:mm:ss Z", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601"]
            locale => "en"
            target => "@timestamp"
            timezone => "UTC"
        }
    }

   else if [parttype] == "container-host" and [path] =~ "mcelog" {

      date{
            locale => "en"
            timezone => "UTC"
            match => ["timestamp", "MMM dd HH:mm:ss", "MMM  d HH:mm:ss", "ISO8601", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "dd/MMM/yyyy:HH:mm:ss Z"]
            target => "@timestamp"
        }
        grok {
            match => [ "path", "/opt/emc/caspian/logs/container-host%{GREEDYDATA:restOfThePath}"]
        }
        mutate {
            replace => { "path" => "/var/log%{restOfThePath}" }
            remove_field => [ "restOfThePath" ]
        }
    }

    else if [parttype] == "container-host" {
        multiline {
            pattern => "(^\b(?:[0-9]+)\b)|(^\b(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\b)"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                "message", "%{SYSLOG_ECS}",
                # SYSLOGx are various observed patterns in /var/log/messages. Newer ones to be added above these so as to be executed first
                "message", "%{SYSLOG1}",
                "message", "%{SYSLOG2}",
                "message", "%{SYSLOG3}",
                "message", "%{SYSLOG4}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
        date{
            locale => "en"
            timezone => "UTC"
            match => ["timestamp", "MMM dd HH:mm:ss", "MMM  d HH:mm:ss", "ISO8601", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "dd/MMM/yyyy:HH:mm:ss Z"]
            target => "@timestamp"
        }
        grok {
            match => [ "path", "/opt/emc/caspian/logs/container-host%{GREEDYDATA:restOfThePath}"]
        }
        mutate {
            replace => { "path" => "/var/log%{restOfThePath}" }
            remove_field => [ "restOfThePath" ]
        }
        grok {
            match => [
                "message", ".*kernel: scini.*"
            ]
            add_tag => [ "is_scaleio_sdc_message" ]
        }
        if "is_scaleio_sdc_message" in [tags] {
            grok {
                match => [
                    "part", "%{GREEDYDATA}_%{IP:partIP}"
                ]
            }
            mutate {
                replace => { "part" => "ScaleIO_SDC_%{partIP}" }
                replace => { "parttype" => "ScaleIO_SDC" }
                replace => { "device" => "Platform_1" }
                replace => { "devType" => "Platform" }
                remove_field => ["partIP"]
            }
        }
    }

    else if [parttype] == "account" {
        multiline {
            pattern => "^\b(?:[0-9]+)\b|^\["
            negate => "true"
            what => "previous"
        }

        grok {
            match => [
                # For accountaccess.log
                "message", "%{ACCOUNT_ACCESS}",
                # For accountservice.log
                "message", "%{ACCOUNT_SERVICE}",
                # For worker.log
                "message", "%{ACCOUNT_WORKER}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }

        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            target => "@timestamp"
            locale => "en"
            timezone => "UTC"
        }
    }

    else if [parttype] == "scaleio-sds" or [parttype] == "scaleio-mdm" or [parttype] == "scaleio-tiebreaker" {
        multiline {
            pattern => "^\b(?:[0-9]+)\b"
            negate => "true"
            what => "previous"
        }

        grok {
            match => [
                # For SDS, MDM and TB .trc files
                "message", "%{SDS__MDM_TRC__TB1}",
                "message", "%{TB2}",
                # For eventlog.db
                "message", "%{MDM_EVENTLOG}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }

        mutate {
            add_field => { "timestamp" => "%{monthDay}%{monthNum} %{time}" }
        }

        date {
            match => ["timestamp", "ddMM HH:mm:ss.SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            target => "@timestamp"
            locale => "en"
            timezone => "UTC"
        }
    }

    else if [parttype] == "scaleio-gateway" {
        multiline {
            pattern => "^\b(?:[0-9]+)\b"
            negate => "true"
            what => "previous"
        }

        grok {
            match => [
                # For scaleio.log, operations.log, api_operations.log
                "message", "%{GATEWAY_SCALEIO_OPERATIONS_API}",
                # For localhost_access_log.log
                "message", "%{GATEWAY_ACCESS}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}"
            ]
        }

        mutate {
            add_field => { "timestamp" => "%{monthDay}%{monthNum}%{year} %{time}" }
        }

        date {
            match => ["timestamp", "ddMMYYYY HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "dd/MMM/yyyy:HH:mm:ss Z" , "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601"]
            target => "@timestamp"
            locale => "en"
            timezone => "UTC"
        }
    }

    else if [parttype] == "scaleio-controller"{
        multiline {
            pattern => "^([A-a]lert|ALERT|[T|t]race|TRACE|[D|d]ebug|DEBUG|[N|n]otice|NOTICE|[I|i]nfo|INFO|[W|w]arn?(?:ing)?|WARN?(?:ING)?|[E|e]rr?(?:or)?|ERR?(?:OR)?|[C|c]rit?(?:ical)?|CRIT?(?:ICAL)?|[F|f]atal|FATAL|[S|s]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)?)"
            negate => "true"
            what => "previous"
        }

        grok {
            match => [
                # For scaleiocontroller.log
                "message", "%{SCALEIO_CONTROLLER}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }

        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS" , "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            target => "@timestamp"
            locale => "en"
            timezone => "UTC"
        }
    }

    else if [parttype] == "ui" or [parttype] == "kibana" or [parttype] == "nginx" or [parttype] == "haproxy" or [parttype] == "cc_nginx"{
        multiline {
            pattern => "^\b(?:[0-9]+)\b|^\[|^Client"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For nginx_access.log
                "message", "%{COMBINEDAPACHELOG_CUSTOM}",
                # For nginx_error.log
                "message", "%{NGINX_ERROR}",
                # For application.log
                "message", "%{APPLICATION1}",
                "message", "%{APPLICATION2}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}"
            ]
        }

        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss", "YYYY/MM/dd HH:mm:ss", "dd/MMM/yyyy:HH:mm:ss Z", "ddMMYYYY HH:mm:ss", "ISO8601", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "logstash" {
        multiline {
            pattern => "^{"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                "message", "%{LOGSTASH_WITHSEVERITY}",
                "message", "%{LOGSTASH}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }

        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS", "ISO8601", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "bigdata-ambari" and [path] =~ "yarn" {
        multiline {
            pattern => "^%{MONTH}"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                "message", "%{YARN}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
        mutate {
            add_field => { "timestamp" => "%{monthDay}%{month}%{year} %{time} %{AMorPM}"}
        }
        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS", "ddMMMYYYY HH:mm:ss,SSS", "ISO8601", "ddMMMYYYY hh:mm:ss aa", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "bigdata-ambari" or [parttype] == "bigdata-hadoop"{
        multiline {
            pattern => "(^%{NONNEGINT}|^([A-a]lert|ALERT|[T|t]race|TRACE|[D|d]ebug|DEBUG|[N|n]otice|NOTICE|[I|i]nfo|INFO|[W|w]arn(?:ing)?|WARN(?:ING)?|[E|e]rror|ERROR|[C|c]rit?(?:ical)?|CRIT?(?:ICAL)?|[F|f]atal|FATAL|[S|s]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)?))"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                "message", "%{AMBARI_AGENT}",
                "message", "%{AMBARI_SERVER}",
                "message", "%{HDFS}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
        mutate {
            add_field => { "timestamp" => "%{monthDay}%{month}%{year} %{time}" }
        }
        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS", "ddMMMYYYY HH:mm:ss,SSS", "ISO8601", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "bigdata-zookeeper" or [parttype] == "bigdata-controller" {
        multiline {
            pattern => "^\b(?:[0-9]+)\b|^\s*([A-a]lert|ALERT|[T|t]race|TRACE|[D|d]ebug|DEBUG|[N|n]otice|NOTICE|[I|i]nfo|INFO|[W|w]arn(?:ing)?|WARN(?:ING)?|[E|e]rror|ERROR|[C|c]rit?(?:ical)?|CRIT?(?:ICAL)?|[F|f]atal|FATAL|[S|s]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)?)"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                "message", "%{ZOOKEEPER__BIGDATA_CONTROLLER1}",
                "message", "%{BIGDATA_CONTROLLER2}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]

        }
        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }


    else if [parttype] == "mnr-collector" or [parttype] == "mnr-backend" or [parttype] == "mnr-frontend" or [parttype] == "mnr-allinone" and [path] =~ "sel.log" {
        grok {
            match => [
                "message", "%{MNR_SEL}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
         mutate {
            add_field => { "timestamp" => "%{date} %{time}"}
        }
        date {
            match => ["timestamp", "MM/dd/YYYY HH:mm:ss", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }


    else if [parttype] == "mnr-collector" or [parttype] == "mnr-backend" or [parttype] == "mnr-frontend" or [parttype] == "mnr-allinone" and ( [path] =~ "catalina" or [path] =~ "localhost" or [path] =~ "mysql" ) {
        multiline {
            pattern => "^%{MONTH}"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                "message", "%{MNR_CATALINA}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
         mutate {
            add_field => { "timestamp" => "%{monthDay}%{month}%{year} %{time} %{AMorPM}"}
        }
        date {
            match => ["timestamp", "ddMMMYYYY hh:mm:ss aa", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "mnr-collector" or [parttype] == "mnr-backend" or [parttype] == "mnr-frontend" or [parttype] == "mnr-allinone" {
        multiline {
            pattern => "^([A-a]lert|ALERT|[T|t]race|TRACE|[D|d]ebug|DEBUG|[N|n]otice|NOTICE|[I|i]nfo|INFO|[W|w]arn(?:ing)?|WARN(?:ING)?|[E|e]rror|ERROR|[C|c]rit?(?:ical)?|CRIT?(?:ICAL)?|[F|f]atal|FATAL|[S|s]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)?)|^(?>\d\d){2}|^FINE"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                "message", "%{MNR}",
                "message", "%{MNR_ALLINONE}",
                "message", "%{MNR_AUDIT}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss", "ISO8601", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "bedrock" {
        multiline {
            pattern => "^([A-a]lert|ALERT|[T|t]race|TRACE|[D|d]ebug|DEBUG|[N|n]otice|NOTICE|[I|i]nfo|INFO|[W|w]arn(?:ing)?|WARN(?:ING)?|[E|e]rror|ERROR|[C|c]rit?(?:ical)?|CRIT?(?:ICAL)?|[F|f]atal|FATAL|[S|s]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)?)|^\[|^%{IP}"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # Bedrock - access.log
                "message", "%{COMBINEDAPACHELOG_CUSTOM}",
                # Bedrock - bedrock.log
                "message", "%{BEDROCK}",
                # Bedrock - error.log
                "message", "%{BEDROCK_ERROR}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}"
            ]
        }
        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss", "dd/MMM/yyyy:HH:mm:ss Z", "ISO8601", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "logcourier" {
        multiline {
            pattern => "^\b(?:[0-9]+)\b"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                "message", "%{LOGCOURIER}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "node-inventory" or [parttype] == "registry"  or [parttype] == "component-registry" or [parttype] == "upgrade" {

        # drop access logs from component-registry-requests.log
        if [path] =~ "component-registry-requests.log" {
            drop { }
        }

        multiline {
            pattern => "^([A-a]lert|ALERT|[T|t]race|TRACE|[D|d]ebug|DEBUG|[N|n]otice|NOTICE|[I|i]nfo|INFO|[W|w]arn(?:ing)?|WARN(?:ING)?|[E|e]rror|ERROR|[C|c]rit?(?:ical)?|CRIT?(?:ICAL)?|[F|f]atal|FATAL|[S|s]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)?)|^\b(?:[0-9]+)\b"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For node-inventory.log and component-registry.log
                "message", "%{INVENTORY__REGISTRY__UPGRADE}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}"
            ]
        }
        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS", "dd/MMM/yyyy:HH:mm:ss Z", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "license" {
        multiline {
            pattern => "^\b(?:[0-9]+)\b"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For licenseservice.log
                "message", "%{LICENSE__DBCONTROLLER}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "ospf-usvc" {
        multiline {
            pattern => "^(?>\d\d){1,2}|^\[|^([A-a]lert|ALERT|[T|t]race|TRACE|[D|d]ebug|DEBUG|[N|n]otice|NOTICE|[I|i]nfo|INFO|[W|w]arn(?:ing)?|WARN(?:ING)?|[E|e]rror|ERROR|[C|c]rit?(?:ical)?|CRIT?(?:ICAL)?|[F|f]atal|FATAL|[S|s]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)?)"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                # For supervisord.log
                "message", "%{OSPF_SUPERVISORD}",
                "message", "%{SYSLOG2}",
                "message", "%{OSPF_ERROR}",
                "message", "%{OSPF_REST}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}"
            ]
        }
        date {
            match => ["timestamp", "ISO8601", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss.SSS", "dd/MMM/yyyy:HH:mm:ss Z", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSSSSS"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "bigdata-kdc" {
        multiline {
            pattern => "^%{MONTH}|^(?>\d\d){2}"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                "message", "%{KDC}",
                "message", "%{KDC_SUPERVISORD}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS", "MMM dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "platform-controller"{
        multiline {
            pattern => "^([A-a]lert|ALERT|[T|t]race|TRACE|[D|d]ebug|DEBUG|[N|n]otice|NOTICE|[I|i]nfo|INFO|[W|w]arn(?:ing)?|WARN(?:ING)?|[E|e]rror|ERROR|[C|c]rit?(?:ical)?|CRIT?(?:ICAL)?|[F|f]atal|FATAL|[S|s]evere|SEVERE|EMERG(?:ENCY)?|[Ee]merg(?:ency)?)"
            negate => "true"
            what => "previous"
        }

        grok {
            match => [
                "message", "%{PLATFORM_CONTROLLER}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }

        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS" , "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            target => "@timestamp"
            locale => "en"
            timezone => "UTC"
        }
    }

    else if [parttype] == "esrs" {
        multiline {
            pattern => "^(?>\d\d){2}"
            negate => "true"
            what => "previous"
        }
        grok {
            match => [
                "message", "%{ESRS2}",
                "message", "%{ESRS}",
                "message", "%{ESRS_WITHGMT}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}",
                "message", "%{COMBINEDAPACHELOG_CUSTOM}"
            ]
        }
        date {
            match => ["timestamp", "YYYY-MM-dd HH:mm:ss,SSS", "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601", "dd/MMM/yyyy:HH:mm:ss Z"]
            locale => "en"
            timezone => "UTC"
            target => "@timestamp"
        }
    }

    else if [parttype] == "neutrino_others" {
        grok {
            match => [
                "message", "%{AODH}",
                "message", "%{CONSUL}",
                "message", "%{DESIGNATE}",
                # Generic patterns
                "message", "%{GENERIC_1}",
                "message", "%{GENERIC_2}",
                "message", "%{GENERIC_3}",
                "message", "%{GENERIC_4}"
            ]
        }

        mutate {
            add_field => { "timestamp" => "%{monthday}%{monthnum}%{year} %{time}" }
        }

        date {
            match => ["timestamp", "ddMMYYYY HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSS", "dd/MMM/yyyy:HH:mm:ss Z" , "YYYY-MM-dd HH:mm:ss", "YYYY-MM-dd HH:mm:ss,SSSSSS", "YYYY-MM-dd HH:mm:ss.SSS", "YYYY-MM-dd HH:mm:ss.SSSSSS", "ISO8601"]
            target => "@timestamp"
            locale => "en"
            timezone => "UTC"
        }
    }
    
    # Masking the term next to 'password'
    grok {
        match => [
            "message", "%{GREEDYDATA:beforePassword}password\s*[=:]\s*%{NOTSPACE}%{GREEDYDATA:afterPassword}"
        ]
        remove_field => [ "message" ]
        add_tag => ["password_masked"]
    }
    if "password_masked" in [tags] {
        mutate {
            add_field => { "message" => "%{beforePassword}password=xxxx%{afterPassword}" }
        }
    }
    
    mutate {
        remove_field => ["timestamp", "date", "time", "monthDay", "month", "monthNum", "year", "AMorPM","beforePassword", "afterPassword"]
        uppercase => ["severity"]
        remove_tag => ["_grokparsefailure", "_dateparsefailure"]
    }

    if [severity] == "WARN" {
        mutate {
            update => { "severity" => "WARNING" }
        }
    }

    if [severity] == "CRIT" {
        mutate {
            update => { "severity" => "CRITICAL" }
        }
    }

    # Categorization for time being. Not efficient.

    if [message] =~ "[S|s]tartup|STARTUP|[S|s]hutdown|SHUTDOWN" {
        mutate {
            add_field => { "category" => ["AVAILABILITY"] }
        }

    }
    else if [message] =~ "[E|e]rror|ERROR|[F|f]atal|FATAL" {
        mutate {
            add_field => { "category" => ["ERROR"] }
        }
    }
    else if [message] =~ "[C|c]pu|[B|b]andwidth|[M|m]emory|[T|t]hroughput|CPU|BANDWIDTH|MEMORY|THROUGHPUT" {
        mutate {
            add_field => { "category" => ["PERFORMANCE"] }
        }
    }
    else if [message] =~ "[C|c]apacity|CAPACITY" {
        mutate {
            add_field => { "category" => ["CAPACITY"] }
        }
    }
    else if [message] =~ "[C|c]onf|CONF" {
        mutate {
            add_field => { "category" => ["CONFIGURATION"] }
        }
    }
    else if [message] =~ "[A|a]udit|AUDIT|[A|a]uth|AUTH|[P|p]assword|PASSWORD" or [message] =~ "os-hypervisors" or [path] =~ "access" or [path] =~ "component-registry-requests" {
        mutate {
            add_field => { "category" => ["AUDIT"] }
        }
    }

    else {
        mutate {
            add_field => { "category" => ["UNKNOWN"] }
        }
    }

    # Setting severity of access logs as INFO
    if ![severity] {

        if [path] == "/opt/emc/caspian/logs/nginx/nginx_access.log"{
            mutate {
                add_field => { "severity" => ["DEBUG"] }
            }
        }

        else if [path] =~ "access" or  [path] =~ "component-registry-requests" or [message] =~ "os-hypervisors" {
            mutate {
                add_field => { "severity" => ["INFO"] }
            }
        }
        else {
            mutate {
                add_field => { "severity" => ["UNKNOWN"] }
            }
        }
    }

}

output {
    if [severity] == "DEBUG" or [severity] == "INFO" {
        elasticsearch {
            protocol => http
            host => "ES_URL"
            port => "ES_PORT"
            index => "logstash-shortlived-%{+YYYY.MM.dd}"
        }
    } 
    else {
        elasticsearch {
            protocol => http
            host => "ES_URL"
            port => "ES_PORT"
        }
    }
}

